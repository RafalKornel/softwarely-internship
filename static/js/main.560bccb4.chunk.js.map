{"version":3,"sources":["components/Node.jsx","components/Tree.jsx","components/Explanation.jsx","components/App.jsx","index.js"],"names":["Node","props","handleClick","checked","nodeRef","current","parentName","React","createRef","this","type","name","id","ref","onClick","defaultChecked","htmlFor","className","subNodes","map","subNode","i","key","isButton","shouldRenderButton","button","text","shouldBeOpened","length","Component","Tree","forceUpdate","data","node","ExplanationEn","ExplanationPl","Explanation","state","en","switch","bind","setState","value","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.560bccb4.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Node extends React.Component {\n    constructor(props) {\n        super(props);\n\n        /**\n         * This property is not in state, because I don't want to \n         * trigger any re-render on mutation. It's updated every time\n         * user interacts with parent (tree) component, and is used \n         * to allow user to uncheck radio input.\n         */\n        this.checked = props.parentName === \"root\";\n        this.nodeRef = React.createRef();\n    }\n\n    shouldBeOpened() {\n        /**\n         * Checks wheter component should hide or show sub nodes\n         */\n        if (this.nodeRef.current) {\n            this.checked = this.nodeRef.current.checked;\n            return this.checked;\n        }\n        if (this.props.parentName === \"root\") {\n            return true;\n        }\n        return false;\n    }\n\n    handleClick = () => {\n        /**\n         * This function is called onClick, it is neccesary to\n         * chech wheter clicked input should be unchecked.\n         * Without it, radio buttons cannot be unchecked.\n         */\n        if (this.checked) {\n            this.nodeRef.current.checked = false;\n        }\n    }\n\n    button() {\n        /**\n         * Returns clickable header to render\n         */\n        return (\n            <>\n                <input\n                    type={this.props.type}\n                    name={this.props.parentName}\n                    id={this.props.name}\n                    ref={this.nodeRef}\n                    onClick={this.handleClick}\n                    defaultChecked={this.props.parentName === \"root\"}\n                />\n                <label htmlFor={this.props.name}>{this.props.name}</label>\n            </>);\n    }\n\n    text() {\n        /**\n         * Returns header if component should not be clickable\n         */\n        return (<span className=\"node__text\">{this.props.name}</span>);\n    }\n\n    subNodes() {\n        /**\n         * Returns array of subnodes to render\n         */\n        return (this.props.subNodes.map((subNode, i) =>\n            <Node\n                {...subNode}\n                parentName={this.props.name}\n                key={i} />\n        )\n        );\n    }\n\n    shouldRenderButton() {\n        /**\n         * Checks wheter component's header should be clickable\n         */\n        return (this.props.type === \"checkbox\" || this.props.type === \"radio\")\n    }\n\n    render() {\n        const isButton = this.shouldRenderButton();\n\n        return (\n            <div className={\"node\" + (isButton ? \"\" : \" node--text\")}>\n                <div className=\"node__header\">\n                    {isButton\n                        ? this.button()\n                        : this.text()}\n                </div>\n                <div className={\"node__children\" + (this.shouldBeOpened() ? \"\" : \"--hidden\")}>\n                    {this.props.subNodes.length > 0 && this.subNodes()}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Node;","import React from \"react\";\nimport Node from \"./Node\";\n\nexport default class Tree extends React.Component {\n    /**\n     * I am using class components here instead of \n     * functional, stateless component just for *this.forceUpdate*\n     * method. It is neccessary, because it forces react to recalculate \n     * every render function on every click, allowing us to pull current \n     * state from pure DOM, after every interaction. I am doing so, because \n     * DOM can manage radio buttons state very easily. I am aware, that this \n     * is not very *React* way of doing things, but it is dictated by \n     * specification of task.\n     */\n    render() {\n        return (\n            <div\n                className=\"tree\"\n                onClick={() => this.forceUpdate()} >\n                {this.props.data.map((node, i) => (\n                    <Node\n                        {...node}\n                        key={i}\n                        parentName=\"root\" />\n                ))}\n            </div>\n        );\n    }\n}","import React from \"react\";\n\nconst ExplanationEn = () => (\n    <section>\n        <h1>Explanation</h1>\n        <p>This is my solution for Softwarely front-end internship recruitment task. The problem was to create accordion-like list, that would be fed data from JSON format, had to manage arbitrary number of nesting, and implement two types of cards: checkboxes and radios. The behaviour is same as HTML's radio/checkbox input, but with small difference, in this app you can uncheck (close) radio button.</p>\n        <p>The JSON file structure is as follows: <br />\n        <code>\n            {\"{\"} <br />\n                <span /> \"name\": {\"<\"} string {\">\"} Will be shown in header.<br />\n                <span /> \"type\": {\"<\"} \"radio\" | \"checkbox\" | none {\">\"} Determines type of card. If ommited, will use name as header and only show message. <br />\n                <span /> \"subNodes\": {\"<\"} array {\">\"} Contains all child nodes, which are the same shape as parent.<br />\n             {\"{\"} <br />\n        </code>\n            It contains only 3 fields: name, type and list of inner elements. This scructure \n            allows to easily create very complex list. </p>\n\n        <p> The code has beed writte in Javascript, with React library. It helped with DOM manipulation (adding, removing elements)</p>\n        <p> Considering data format, the list is created recursively. Code contains two components, Tree (which is a wrapper for whole list), and Node.</p>\n        <p> The second one recursively renders data inside itself, from JSON file. Considering specification of problem, components use\n            state contained in original DOM tree. </p>\n        <p> Because of this, it was easier to mainain state of components. It could be problematic otherwise, because components are recursive, and in order to recreate radio input behaviour,\n            the state would need to be lifted to common parent. This solution would add more complexity to code. Instead, \"name\" attribute of HTML element \"input\" was used, recreating radio input behaviour. </p>\n        <p> In order to provide full functionality (hiding radio cards), Node component has \"checked\" field, which is updated (synchronised) with DOM value every time tree updates.\n            This, again is not really proper way of solving problem in React, but it did it's job. </p>\n        <p> React refreshes components only upon change of props or state. Neither of those were changing in solution, thus Tree component refreshes whole tree of nodes upon every click. This was \n            achieved thanks to forceUpdate lifecycle method. </p>\n        <p> Storing state in DOM is not \"React way\", but usage of this pattern is justified in current context. React rule, one source of truth, was preserved.</p>\n\n    </section>\n);\n\nconst ExplanationPl = () => (\n    <section>\n        <h1>Wyja≈õnienie</h1>\n        <p>Po lewej stronie znajduje siƒô moje rozwiƒÖzanie zadania rekrutacyjnego na stanowisko intern front-end developera. Zadanie polega≈Ço na stworzeniu rozwijanej listy, o dowolnej g≈Çƒôboko≈õci, z dwoma rodzajami przycisk√≥w: radio oraz checkbox. Zachowanie przycisk√≥w jest analogiczne do element√≥w *input* typy radio oraz checkbox, z tƒÖ r√≥≈ºnicƒÖ, ≈ºe w moim rozwiƒÖzaniu przycisk radio da siƒô oznaczyƒá (zamknƒÖƒá). Lista powstaje w opraciu o plik JSON.</p>\n        <p>Format pliku JSON jest nastƒôpujƒÖcy: <br />\n        <code>\n            {\"{\"} <br />\n                <span /> \"name\": {\"<\"} string {\">\"} Tekst wy≈õwietlony w nag≈Ç√≥wku karty.<br />\n                <span /> \"type\": {\"<\"} \"radio\" | \"checkbox\" | none {\">\"} Typ komponentu. Pominiƒôcie stworzy nieklikalny element (tekst)\"<br />\n                <span /> \"subNodes\": {\"<\"} array {\">\"} Zawiera wszystkie zagnie≈ºdzone elementy. <br />\n             {\"{\"} <br />\n        </code>\n        Zawiera on jedynie 3 pola: nazwƒô, typ oraz listƒô wewnƒôtrznych element√≥w.\n        Taka struktura pozwala z ≈Çatwy spos√≥b stworzyƒá z≈Ço≈ºonƒÖ listƒô.\n        </p>\n\n        <p> Kod zosta≈Ç napisany w Javascripcie, z wykorzystaniem biblioteki React. U≈Çatwi≈Ça ona znacznie manipulowaniem DOM'em. </p>\n        <p> Z uwagi na rodzaj danych wej≈õciowych, lista jest tworzona rekurencyjnie. W kodzie znajdujƒÖ siƒô dwa komponenty, Tree (kt√≥ry jest tylko \"wrapperem\" na listƒô), oraz Node. </p>\n        <p> Ten drugi rekurencyjnie renderuje wewnƒÖtrz siebie dane z pliku JSON. Z uwagi na specyfikacje problemu, komponenty wykorzystujƒÖ stan przechowywany w oryginalnym drzewie DOM. </p>\n        <p> Dziƒôki temu unikniƒôto problemu zarzƒÖdzania stanem ka≈ºdego komponentu. Mog≈Çoby to byƒá problematyczne, poniewa≈º komponenty sƒÖ rekurencyjne, a ≈ºeby odtworzyƒá dzia≈Çanie radio input'u, nale≈ºy\n            podnie≈õƒá stan do wsp√≥lnego komponentu. RozwiƒÖzanie to, jakkolwiek poprawne, doda≈Çoby z≈Ço≈ºono≈õci aplikacji.\n            Zamiast tego wykorzystano atrybut \"name\" elementu HTML \"input\".  </p>\n        <p> Aby zapewniƒá pe≈ÇnƒÖ funkcjonalno≈õƒá (zamykanie kart typu radio), komponent Node zawiera pole \"checked\", kt√≥re jest aktualizowane za ka≈ºdym od≈õwie≈ºeniem drzewa.</p>\n        <p> React od≈õwie≈ºa komponenty jedynie przy zmianie props'√≥w, lub stanu. Poniewa≈º w rozwiƒÖzaniu ≈ºadne z dw√≥ch siƒô nie zmienia (stan trzymany jest \n            przez DOM), komponent Tree przy ka≈ºdym klikniƒôciu od≈õwie≈ºa ca≈Çe drzewo. Dokonano to za pomocƒÖ funkcji cyklu ≈ºycia forceUpdate. </p>\n        <p> Przechowywanie stanu w DOM'ie nie jest zgodne z filozofiƒÖ Reacta, jednak wykorzystanie tego schematu jest usprawieliwione w tym przypadku, tak≈ºe zosta≈Çy \n            zachowane inne zasady Reacta (jedno ≈∫r√≥d≈Ço prawdy) </p>\n    </section>\n)\n\nclass Explanation extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            en: true,\n        }\n\n        this.switch = this.switch.bind(this);\n    }\n\n    switch() {\n        this.setState(state => ({en: !state.en}) );\n    }\n\n    render() {\n        return(\n            <>\n                <input\n                    type=\"button\" \n                    value={ this.state.en ? \"PL\" : \"EN\" } \n                    onClick={this.switch}\n                    className=\"langSwitch\" />\n                { this.state.en\n                  ? <ExplanationEn />\n                  : <ExplanationPl /> }\n            </>\n        );\n    }\n}\n\nexport default Explanation;","import React from \"react\";\nimport Tree from \"./Tree\";\nimport Explanation from \"./Explanation\";\nimport data from \"../structure.json\";\n\nconst App = (props) => (\n    <>\n        <Tree data={data} />\n        <Explanation />\n    </>\n);\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './style/style.css';\nimport App from \"./components/App\";\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}