{"version":3,"sources":["components/Node.jsx","components/Tree.jsx","components/Explanation.jsx","components/App.jsx","index.js"],"names":["Node","props","handleClick","checked","nodeRef","current","parentName","React","createRef","this","type","name","id","ref","onClick","defaultChecked","htmlFor","className","subNodes","map","subNode","i","key","isButton","shouldRenderButton","button","text","shouldBeOpened","length","Component","Tree","forceUpdate","data","node","ExplanationEn","ExplanationPl","Explanation","state","en","switch","bind","setState","value","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.560bccb4.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Node extends React.Component {\n    constructor(props) {\n        super(props);\n\n        /**\n         * This property is not in state, because I don't want to \n         * trigger any re-render on mutation. It's updated every time\n         * user interacts with parent (tree) component, and is used \n         * to allow user to uncheck radio input.\n         */\n        this.checked = props.parentName === \"root\";\n        this.nodeRef = React.createRef();\n    }\n\n    shouldBeOpened() {\n        /**\n         * Checks wheter component should hide or show sub nodes\n         */\n        if (this.nodeRef.current) {\n            this.checked = this.nodeRef.current.checked;\n            return this.checked;\n        }\n        if (this.props.parentName === \"root\") {\n            return true;\n        }\n        return false;\n    }\n\n    handleClick = () => {\n        /**\n         * This function is called onClick, it is neccesary to\n         * chech wheter clicked input should be unchecked.\n         * Without it, radio buttons cannot be unchecked.\n         */\n        if (this.checked) {\n            this.nodeRef.current.checked = false;\n        }\n    }\n\n    button() {\n        /**\n         * Returns clickable header to render\n         */\n        return (\n            <>\n                <input\n                    type={this.props.type}\n                    name={this.props.parentName}\n                    id={this.props.name}\n                    ref={this.nodeRef}\n                    onClick={this.handleClick}\n                    defaultChecked={this.props.parentName === \"root\"}\n                />\n                <label htmlFor={this.props.name}>{this.props.name}</label>\n            </>);\n    }\n\n    text() {\n        /**\n         * Returns header if component should not be clickable\n         */\n        return (<span className=\"node__text\">{this.props.name}</span>);\n    }\n\n    subNodes() {\n        /**\n         * Returns array of subnodes to render\n         */\n        return (this.props.subNodes.map((subNode, i) =>\n            <Node\n                {...subNode}\n                parentName={this.props.name}\n                key={i} />\n        )\n        );\n    }\n\n    shouldRenderButton() {\n        /**\n         * Checks wheter component's header should be clickable\n         */\n        return (this.props.type === \"checkbox\" || this.props.type === \"radio\")\n    }\n\n    render() {\n        const isButton = this.shouldRenderButton();\n\n        return (\n            <div className={\"node\" + (isButton ? \"\" : \" node--text\")}>\n                <div className=\"node__header\">\n                    {isButton\n                        ? this.button()\n                        : this.text()}\n                </div>\n                <div className={\"node__children\" + (this.shouldBeOpened() ? \"\" : \"--hidden\")}>\n                    {this.props.subNodes.length > 0 && this.subNodes()}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Node;","import React from \"react\";\nimport Node from \"./Node\";\n\nexport default class Tree extends React.Component {\n    /**\n     * I am using class components here instead of \n     * functional, stateless component just for *this.forceUpdate*\n     * method. It is neccessary, because it forces react to recalculate \n     * every render function on every click, allowing us to pull current \n     * state from pure DOM, after every interaction. I am doing so, because \n     * DOM can manage radio buttons state very easily. I am aware, that this \n     * is not very *React* way of doing things, but it is dictated by \n     * specification of task.\n     */\n    render() {\n        return (\n            <div\n                className=\"tree\"\n                onClick={() => this.forceUpdate()} >\n                {this.props.data.map((node, i) => (\n                    <Node\n                        {...node}\n                        key={i}\n                        parentName=\"root\" />\n                ))}\n            </div>\n        );\n    }\n}","import React from \"react\";\n\nconst ExplanationEn = () => (\n    <section>\n        <h1>Explanation</h1>\n        <p>This is my solution for Softwarely front-end internship recruitment task. The problem was to create accordion-like list, that would be fed data from JSON format, had to manage arbitrary number of nesting, and implement two types of cards: checkboxes and radios. The behaviour is same as HTML's radio/checkbox input, but with small difference, in this app you can uncheck (close) radio button.</p>\n        <p>The JSON file structure is as follows: <br />\n        <code>\n            {\"{\"} <br />\n                <span /> \"name\": {\"<\"} string {\">\"} Will be shown in header.<br />\n                <span /> \"type\": {\"<\"} \"radio\" | \"checkbox\" | none {\">\"} Determines type of card. If ommited, will use name as header and only show message. <br />\n                <span /> \"subNodes\": {\"<\"} array {\">\"} Contains all child nodes, which are the same shape as parent.<br />\n             {\"{\"} <br />\n        </code>\n            It contains only 3 fields: name, type and list of inner elements. This scructure \n            allows to easily create very complex list. </p>\n\n        <p> The code has beed writte in Javascript, with React library. It helped with DOM manipulation (adding, removing elements)</p>\n        <p> Considering data format, the list is created recursively. Code contains two components, Tree (which is a wrapper for whole list), and Node.</p>\n        <p> The second one recursively renders data inside itself, from JSON file. Considering specification of problem, components use\n            state contained in original DOM tree. </p>\n        <p> Because of this, it was easier to mainain state of components. It could be problematic otherwise, because components are recursive, and in order to recreate radio input behaviour,\n            the state would need to be lifted to common parent. This solution would add more complexity to code. Instead, \"name\" attribute of HTML element \"input\" was used, recreating radio input behaviour. </p>\n        <p> In order to provide full functionality (hiding radio cards), Node component has \"checked\" field, which is updated (synchronised) with DOM value every time tree updates.\n            This, again is not really proper way of solving problem in React, but it did it's job. </p>\n        <p> React refreshes components only upon change of props or state. Neither of those were changing in solution, thus Tree component refreshes whole tree of nodes upon every click. This was \n            achieved thanks to forceUpdate lifecycle method. </p>\n        <p> Storing state in DOM is not \"React way\", but usage of this pattern is justified in current context. React rule, one source of truth, was preserved.</p>\n\n    </section>\n);\n\nconst ExplanationPl = () => (\n    <section>\n        <h1>Wyjaśnienie</h1>\n        <p>Po lewej stronie znajduje się moje rozwiązanie zadania rekrutacyjnego na stanowisko intern front-end developera. Zadanie polegało na stworzeniu rozwijanej listy, o dowolnej głębokości, z dwoma rodzajami przycisków: radio oraz checkbox. Zachowanie przycisków jest analogiczne do elementów *input* typy radio oraz checkbox, z tą różnicą, że w moim rozwiązaniu przycisk radio da się oznaczyć (zamknąć). Lista powstaje w opraciu o plik JSON.</p>\n        <p>Format pliku JSON jest następujący: <br />\n        <code>\n            {\"{\"} <br />\n                <span /> \"name\": {\"<\"} string {\">\"} Tekst wyświetlony w nagłówku karty.<br />\n                <span /> \"type\": {\"<\"} \"radio\" | \"checkbox\" | none {\">\"} Typ komponentu. Pominięcie stworzy nieklikalny element (tekst)\"<br />\n                <span /> \"subNodes\": {\"<\"} array {\">\"} Zawiera wszystkie zagnieżdzone elementy. <br />\n             {\"{\"} <br />\n        </code>\n        Zawiera on jedynie 3 pola: nazwę, typ oraz listę wewnętrznych elementów.\n        Taka struktura pozwala z łatwy sposób stworzyć złożoną listę.\n        </p>\n\n        <p> Kod został napisany w Javascripcie, z wykorzystaniem biblioteki React. Ułatwiła ona znacznie manipulowaniem DOM'em. </p>\n        <p> Z uwagi na rodzaj danych wejściowych, lista jest tworzona rekurencyjnie. W kodzie znajdują się dwa komponenty, Tree (który jest tylko \"wrapperem\" na listę), oraz Node. </p>\n        <p> Ten drugi rekurencyjnie renderuje wewnątrz siebie dane z pliku JSON. Z uwagi na specyfikacje problemu, komponenty wykorzystują stan przechowywany w oryginalnym drzewie DOM. </p>\n        <p> Dzięki temu uniknięto problemu zarządzania stanem każdego komponentu. Mogłoby to być problematyczne, ponieważ komponenty są rekurencyjne, a żeby odtworzyć działanie radio input'u, należy\n            podnieść stan do wspólnego komponentu. Rozwiązanie to, jakkolwiek poprawne, dodałoby złożoności aplikacji.\n            Zamiast tego wykorzystano atrybut \"name\" elementu HTML \"input\".  </p>\n        <p> Aby zapewnić pełną funkcjonalność (zamykanie kart typu radio), komponent Node zawiera pole \"checked\", które jest aktualizowane za każdym odświeżeniem drzewa.</p>\n        <p> React odświeża komponenty jedynie przy zmianie props'ów, lub stanu. Ponieważ w rozwiązaniu żadne z dwóch się nie zmienia (stan trzymany jest \n            przez DOM), komponent Tree przy każdym kliknięciu odświeża całe drzewo. Dokonano to za pomocą funkcji cyklu życia forceUpdate. </p>\n        <p> Przechowywanie stanu w DOM'ie nie jest zgodne z filozofią Reacta, jednak wykorzystanie tego schematu jest usprawieliwione w tym przypadku, także zostały \n            zachowane inne zasady Reacta (jedno źródło prawdy) </p>\n    </section>\n)\n\nclass Explanation extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            en: true,\n        }\n\n        this.switch = this.switch.bind(this);\n    }\n\n    switch() {\n        this.setState(state => ({en: !state.en}) );\n    }\n\n    render() {\n        return(\n            <>\n                <input\n                    type=\"button\" \n                    value={ this.state.en ? \"PL\" : \"EN\" } \n                    onClick={this.switch}\n                    className=\"langSwitch\" />\n                { this.state.en\n                  ? <ExplanationEn />\n                  : <ExplanationPl /> }\n            </>\n        );\n    }\n}\n\nexport default Explanation;","import React from \"react\";\nimport Tree from \"./Tree\";\nimport Explanation from \"./Explanation\";\nimport data from \"../structure.json\";\n\nconst App = (props) => (\n    <>\n        <Tree data={data} />\n        <Explanation />\n    </>\n);\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './style/style.css';\nimport App from \"./components/App\";\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}